{
  "name": "parsley",
  "description": "pure javascript http parser",
  "version": "0.1.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/substack/node-parsley.git"
  },
  "main": "index.js",
  "keywords": [
    "http",
    "parser"
  ],
  "directories": {
    "lib": ".",
    "example": "example",
    "test": "test"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "dependencies": {},
  "devDependencies": {
    "tap": "0.1.x",
    "chunky": "0.0.x"
  },
  "engines": {
    "node": ">=0.4.0"
  },
  "license": "MIT",
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "readme": "parsley\n=======\n\nHTTP parser written in node with hooks into the raw header and raw body.\n\nYou should only need this module if you're writing an HTTP proxy or something\nsimilarly nefarious.\n\n[![build status](https://secure.travis-ci.org/substack/node-parsley.png)](http://travis-ci.org/substack/node-parsley)\n\nexample\n=======\n\nheaders.js\n----------\n\n````javascript\nvar parsley = require('parsley');\nvar net = require('net');\n\nnet.createServer(function (stream) {\n    parsley(stream, function (req) {\n        req.on('headers', function (headers) {\n            console.log(req.method + ' ' + req.url + 'HTTP/' + req.httpVersion);\n            console.dir(headers);\n        });\n    });\n}).listen(7000);\n````\n\n````\n$ curl localhost:7000/zing\n^C\n$ \n````\n\n````\n$ node example/headers.js \nGET /zingHTTP/1.1\n{ 'user-agent': 'curl/7.21.3 (x86_64-pc-linux-gnu) libcurl/7.21.3 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18',\n  host: 'localhost:7000',\n  accept: '*/*' }\n\n````\n\nraw.js\n------\n\n````javascript\nvar parsley = require('parsley');\nvar net = require('net');\n\nnet.createServer(function (stream) {\n    parsley(stream, function (req) {\n        var head = [];\n        req.on('rawHead', function (buf) {\n            head.push(buf);\n        });\n        \n        var body = [];\n        req.on('rawBody', function (buf) {\n            body.push(buf);\n        });\n        \n        req.on('end', function () {\n            console.dir(head.map(String));\n            console.dir(body.map(String));\n        });\n    });\n}).listen(7000);\n````\n\n````\n$ echo beep | curl -sNT. localhost:7000\n^C\n$ \n````\n\n````\n$ node example/raw.js \n[ 'PUT ',\n  '/ ',\n  'HTTP/',\n  '1.1\\r\\n',\n  'User-Agent:',\n  ' curl/7.21.3 (x86_64-pc-linux-gnu) libcurl/7.21.3 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18\\r\\n',\n  'Host:',\n  ' localhost:7000\\r\\n',\n  'Accept:',\n  ' */*\\r\\n',\n  'Transfer-Encoding:',\n  ' chunked\\r\\n',\n  'Expect:',\n  ' 100-continue\\r\\n',\n  '\\r\\n' ]\n[ '5\\r\\n', 'beep\\n', '\\r\\n', '0\\r\\n', '\\r\\n' ]\n\n````\n\nmethods\n=======\n\nvar parsley = require('parsley')\n\nvar p = parsley(stream, cb)\n---------------------------\n\nParse `stream`, calling `cb` with a new `http.IncomingMessage`\nobject as soon as the first piece of data comes in.\n\nIf the connection is keep-alive, multiple requests may come through `cb` on the\nsame stream.\n\np.upgrade()\n-----------\n\nPut the parser into upgrade mode manually. This is done automatically when the\n\"upgrade\" header is present or \"connection: upgrade\".\n\nevents\n======\n\nThe `http.IncomingMessage` that `cb` gets called with has these events:\n\n\"data\", buf\n-----------\n\nEmitted when data comes in not including the extra pieces like transfer-encoding\nframing.\n\n\"headers\", headers\n------------------\n\nEmitted when all the `req.headers` have arrived.\n\n\"end\"\n-----\n\nEmitted when all the request data has been received, not including trailing\nframing such as the last newline.\n\n\"rawHead\", buf\n--------------\n\nEmitted whenever any data comes in before the body.\n\n\"rawBody\", buf\n--------------\n\nEmitted whenever any data comes in after the header but before the request ends\nfor the case of keep-alive requests.\n\n\"rawEnd\"\n--------\n\nEmitter when the request is complete, including any trailing framing.\n\n\"error\", err\n------------\n\nEmitted when the stream fails to parse.\n\nmotivation\n==========\n\nTurns out, it's super hard to get node's http parser to spit out the raw request\nbuffers only for a particular request. But with parsley, you can listen on\n`'rawHead'` and `'rawBody'` events to get the raw buffer stream as it gets\nparsed.\n\ninstall\n=======\n\nWith [npm](http://npmjs.org) do:\n\n    npm install parsley\n",
  "_id": "parsley@0.1.0",
  "_from": "parsley@0.1.x"
}
