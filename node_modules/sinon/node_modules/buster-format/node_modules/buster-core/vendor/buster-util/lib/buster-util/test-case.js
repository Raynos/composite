var buster = buster || {};
buster.util = buster.util || {};

(function () {
    if (typeof jstestdriver == "object" && !!jstestdriver.console) {
        return;
    }

    if (typeof require == "function") {
        var util = require("util");
        var colors = { "red": 1, "green": 2 };

        buster.util.print = function (message, color) {
            if (color) message = "\033[3" + colors[color] + "m" + message + "\033[39m";
            util.print(message);
        };

        buster.util.puts = function (message, color) {
            buster.util.print(message + "\n");
        };

        buster.util.nextTick = process.nextTick;

        process.on("uncaughtException", function (e) {
            if (!buster.util.testCase.silent) {
                buster.util.puts("Uncaught error");
                buster.util.puts(e.message);
                buster.util.puts(e.stack);
            }
        });
    } else {
        document.body.innerHTML = "<h1>" + document.title + " test</h1><p id=\"report\"></p><ul>";

        var report = document.getElementById("report");

        buster.util.print = function (message, color) {
            message = message.replace(/\n/g, "<br>");

            if (color) {
                message = '<span style="color: ' + color + '">' + message + '</span>';
            }

            report.innerHTML += message;
        };

        buster.util.puts = function (message, color) {
            if (!message) return;
            message = message.replace(/\n/g, "<br>");

            if (color) {
                message = '<span style="color: ' + color + '">' + message + '</span>';
            }

            document.body.innerHTML += "<li>" + message + "</li>";
        };

        buster.util.nextTick = function (callback) {
            setTimeout(callback, 0);
        };

        window.onerror = function (error) {
            if (!buster.util.testCase.silent) {
                buster.util.puts("Uncaught error");
                buster.util.puts([].join.call(arguments));
            }

            return true;
        };
    }

    function fireCompleteCallbackIfDone(testCase) {
        if (testCase.testsRun == testCase.totalTests) {
            buster.util.puts("");

            if (typeof buster.util.testCase.onTestCaseFinished == "function") {
                buster.util.testCase.onTestCaseFinished();
            }
        }
    }

    var asyncTestQueue = [];
    function onAsyncTestFinished() {
        var test = asyncTestQueue.shift();

        if (asyncTestQueue.length > 0) {
            asyncTestQueue[0]();
        }

        if (!test) {
            return;
        }

        fireCompleteCallbackIfDone(test.testCase);
    };

    function asyncTest(testFunction) {
        var asyncTestFunction = function () {
            var self = this;

            buster.util.nextTick(function () {
                testFunction.call(self, self);
            });
        };

        asyncTestFunction.async = true;
        return asyncTestFunction;
    }

    var queue = [], running = false;

    function processQueue() {
        if (running) {
            return;
        }

        running = true;

        setTimeout(function () {
            if (queue.length > 0) {
                var tc = queue.shift();

                function next() {
                    delete buster.util.testCase.onTestCaseFinished;
                    running = false;
                    processQueue();
                }

                if (runTests(tc[0], tc[1])) {
                    buster.util.testCase.onTestCaseFinished = next;
                } else {
                    next();
                }
            }
        }, 10);
    }

    buster.util.testCase = function (name, tests) {
        queue.push([name, tests]);
        processQueue();
    };

    function runTests(name, tests) {
        var failedTests = {};
        tests.testsRun = 0;
        tests.totalTests = 0;
        var isAsync = false;

        buster.util.print(name + ": ");

        for (var test in tests) {
            if (test == "setUp" || test == "tearDown" ||
                typeof tests[test] != "function") {
                continue;
            }

            tests.totalTests++;

            if (!tests[test].async && tests[test].length == 1) {
                tests[test] = asyncTest(tests[test]);
            }

            if (tests[test].async) {
                isAsync = true;

                asyncTestQueue.push((function (test) {
                    var testFunc = function () {
                        var scope = {};
                        var timeout = setTimeout(function () {
                            tests.testsRun += 1;
                            if (tests.tearDown) tests.tearDown.call(scope);
                            buster.util.print("[ASYNC][TIMEOUT] " + test, "red");
                            onAsyncTestFinished();
                        }, 2000);
                        scope.end = function (num) {
                            function complete() {
                                tests.testsRun += 1;
                                clearTimeout(timeout);

                                if (tests.tearDown) {
                                    tests.tearDown.call(scope);
                                }

                                buster.util.print(".", "green");
                                onAsyncTestFinished();
                            }

                            if (num) {
                                setTimeout(complete, num);
                            } else {
                                complete();
                            }
                        };

                        if (tests.setUp) {
                            tests.setUp.call(scope);
                        }

                        tests[test].call(scope);
                    };

                    testFunc.testCase = tests;

                    return testFunc;
                }(test)));

                if (asyncTestQueue.length == 1) {
                    asyncTestQueue[0]();
                }

                buster.util.print(".", "green");
            } else {
                tests.testsRun += 1;
                var scope = {};
                var failedTest;

                try {
                    if (tests.setUp) {
                        tests.setUp.call(scope);
                    }

                    tests[test].call(scope);
                } catch (e) {
                    failedTest = e;
                }

                if (tests.tearDown) {
                    try {
                        tests.tearDown.call(scope);
                    } catch (e) {
                        failedTest = e;
                    }
                }

                if (!failedTest) {
                    buster.util.print(".", "green");
                } else {
                    buster.util.print(".", "red");
                    failedTests[test] = failedTest;
                }
            }
        }

        fireCompleteCallbackIfDone(tests);

        for (var failedTest in failedTests) {
            var e = failedTests[failedTest];
            buster.util.puts(failedTest + " failed:");
            buster.util.puts(e.name + ": " + (e.message || "\nActual:   " + e.actual +
                                              "\nExpected: " + e.expected) +
                             "\n", "red");

            if (e.stack) {
                var lines = e.stack.split("\n");
                var output = [];

                for (var i = 0, l = lines.length; i < l; ++i) {
                    if (/\.js/.test(lines[i])) {
                        output.push(lines[i]);
                    }
                }

                buster.util.puts(output.join("\n"));
            }
        }

        return isAsync;
    };

    // Can be used to create asynchronous tests. I.e.:
    //
    //   testCase("foo", {
    //       "test me": testCase.async(function (self) {
    //           doAsyncStuff(function () {
    //               self.end(); // call when test is finished
    //           });
    //       })
    //   });
    buster.util.testCase.async = asyncTest;
}());

if (typeof require == "function" && typeof module == "object") {
    module.exports = buster.util.testCase;
}
